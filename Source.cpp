/*
В предыдущем варианте найдено 2 ошибки.
1) Созданные сокеты не закрывались и продолжали висеть открытыми,
со временем они бы закончились и программа упала(предположительно с ошибкой INVALID_SOCKET).
2) 2я ошибка это сделать vector(в роли FIFO-очереди) из несколиких элементов,
но оставить обращение к нулевому(крайнему) элементу по индексу ( mybuffer[0] ),
в таком случае, если поток добавляющий элементы в vector будет работать быстрее
потока читающего и очищающего элементы vector'а, то уже на 2й итерации поток
затрет предыдущее значение еще не освобожденного элемента.
Таким образом произойдет сразу 2 ошибки:
1) Потеря части информации;
2) Утечка памяти из за потерянных указателей (см. free()).
*/

/*
* Адрес ресурса задается 1м аргументом в командной строке.
* Порт задается 2м аргументом, если его нет то по умолчанию будет 80.
* URI задается 3м аргументом, если его нет то по умолчанию будет "/".
* 4м аргументом, можно записать "ключ" debug и получить некоторое количество отладочной инфы. Совсем чуть-чуть...
* Пока никаких проверок и ключей командной строки не делаем.
* Чтобы задать какой либо ключ принудительно, нужно правильно задать все предыдущие ключи. Пока так.
* Метод, пока, только GET.
* Пока только IPv4.
* Выход из программы осуществляется двойным нажатием ESC.
*/
#pragma once
#include "mainh.h"

/*
*
*/

int exit_flag = 0; // Флаг который будет выставляться в 1 когда нажата клавиша ESC.
int sleep_timeout = 3000; // 3 секунды.
mutex mainMut;

int main(int argc, char** argv) {

	if (argc <= 1) {
		cout << "Usage: <host> <port> <URI> <debug> <timeout>" << endl;
		return 0;
	}
	else if (argc >= 6)
		sleep_timeout = atoi(argv[5]) * 1000;

	vector<char*> mybuffer;

	// std::ref() - для передачи переменной в поток по ссылке! https://habrahabr.ru/post/182610/
	// передать по ссылке как в обычную функцию не получится, а по указателю вектор передать не получится.
	thread thr1(get_data, argc, argv, ref(mybuffer));

	for (;;) {
		if (exit_flag)
			break;
		// Проверка нажатия клавиши.
		if (_kbhit())
			if (_getch() == ESC) {
				exit_flag = 1;
				break;
			}
		// Вывод и очистка.
		if (mybuffer.size()) { // Если количество элементов в векторе не 0.
			mainMut.lock(); // Блокируем доступ к вектору.
							// Получаем значение(указатель) первого элемента (а точнее старшего или крайнего).
							// Выводим содержимое расположенное по указателю до "\0".
			cout << mybuffer.front();
			free(mybuffer.front()); // Освобождаем память по указателю.
			mybuffer.erase(mybuffer.begin()); // Удаляем первый элемент (а точнее старший или крайний).
			mainMut.unlock(); // Разблокируем доступ к вектору.
			Sleep(sleep_timeout); // Сдесь и в функции "get_data", задать произвольные значения или закомментировать в разной последовательности для проверки.
		}
	}
	thr1.join();

	return 0;
}
